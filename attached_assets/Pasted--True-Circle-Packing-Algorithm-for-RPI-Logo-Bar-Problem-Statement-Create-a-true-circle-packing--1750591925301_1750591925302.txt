# True Circle Packing Algorithm for RPI Logo Bar

## Problem Statement
Create a true circle packing algorithm that fills a rectangular bar space with tangent circles (circles that touch but don't overlap), not just a grid of circles. The current implementation uses grid positioning which isn't true circle packing.

## Key Requirements

### 1. Tangent Circle Placement
- Circles must be **tangent** (touching) to their neighbors, not just placed on a grid
- No gaps between circles except where geometry requires it
- Circles should completely fill the available bar space
- Use the **Uniform Neighbor Model** principles from the research paper

### 2. Algorithmic Size Variation
- Start with uniform circle sizes when `sizeVariation = 0`
- As `sizeVariation` increases, introduce **deterministic** size variation
- Use **pseudorandom** generation with fixed seeds for consistent results
- Maintain tangency constraints even with varied sizes

### 3. Pattern Types (Rows)
- **1 ROW**: Single row of tangent circles spanning full width
- **2 ROWS**: Two rows with offset positioning (hexagonal-style packing)
- **3 ROWS**: Three rows with optimal packing efficiency
- **4 ROWS**: Four rows maintaining tangency

### 4. Mathematical Implementation

#### Circle Generation Algorithm:
```javascript
function generatePackedRow(count, width, height, sizeVariation, overlap, y, seedOffset = 0) {
    const circles = [];
    const baseDiameter = Math.min(height * 0.9, width / count * 1.5);
    let currentX = 0;
    
    for (let i = 0; i < count; i++) {
        // Deterministic pseudorandom for size variation
        const seed = ((i + seedOffset) * 9301 + 49297) % 233280;
        const pseudoRandom = seed / 233280.0;
        
        // Apply size variation
        const variationFactor = 1 + (pseudoRandom - 0.5) * (sizeVariation / 100);
        let size = baseDiameter * variationFactor;
        
        // Apply overlap factor
        const overlapFactor = 1 + (overlap / 100);
        size *= overlapFactor;
        
        const radius = size / 2;
        
        // Position calculation for tangency
        if (i === 0) {
            currentX = radius; // First circle starts at its radius
        } else {
            const prevRadius = circles[i-1].size / 2;
            const overlapOffset = overlap > 0 ? (radius + prevRadius) * (overlap / 200) : 0;
            currentX += prevRadius + radius - overlapOffset; // Tangent positioning
        }
        
        circles.push({ x: currentX, y, size });
    }
    
    // Scale all positions to fit exactly within width
    if (circles.length > 0) {
        const lastCircle = circles[circles.length - 1];
        const totalWidth = lastCircle.x + lastCircle.size / 2;
        const scale = width / totalWidth;
        
        circles.forEach(circle => {
            circle.x *= scale;
            circle.size *= scale;
        });
    }
    
    return circles;
}
```

#### Multi-Row Implementation:
```javascript
function generateCirclePackingData(count, width, height, sizeVariation, patternType, overlap) {
    const rows = patternType + 1; // 1-4 rows
    const circles = [];
    
    if (rows === 1) {
        return generatePackedRow(count, width, height, sizeVariation, overlap, height/2);
    }
    
    // Distribute circles among rows
    const circlesPerRow = Math.ceil(count / rows);
    const rowHeight = height / rows;
    
    for (let row = 0; row < rows; row++) {
        const rowStart = row * circlesPerRow;
        const rowEnd = Math.min(rowStart + circlesPerRow, count);
        const rowCount = rowEnd - rowStart;
        
        if (rowCount > 0) {
            const rowY = (row + 0.5) * rowHeight;
            const rowCircles = generatePackedRow(rowCount, width, rowHeight, sizeVariation, overlap, rowY, rowStart);
            
            // For even rows (2nd, 4th), apply horizontal offset for better packing
            if (row % 2 === 1 && rows > 1) {
                const offset = width / (2 * circlesPerRow);
                rowCircles.forEach(circle => {
                    circle.x += offset;
                    // Wrap around if needed
                    if (circle.x > width) circle.x -= width;
                });
            }
            
            circles.push(...rowCircles);
        }
    }
    
    return circles;
}
```

## Shader Implementation Requirements

### Replace the current `getCircleData` function with:
1. **Pre-computed circle positions** using the tangent algorithm above
2. **Proper scaling** to ensure circles fit exactly within bar bounds
3. **Deterministic positioning** that doesn't change between frames
4. **Efficient GPU implementation** of the circle data lookup

### Key Changes Needed:
1. **Remove grid-based positioning** (`colInRow * width/circlesPerRow`)
2. **Implement tangent circle placement** where each circle touches its neighbors
3. **Add proper boundary constraints** so circles don't extend beyond bar edges
4. **Maintain deterministic behavior** with consistent seeding

## Expected Behavior
- **Uniform circles** when `sizeVariation = 0` that perfectly fill the bar width
- **Gradual size variation** as slider increases, maintaining tangency
- **No empty spaces** except where geometric constraints require them
- **Consistent results** - same settings always produce same pattern
- **Efficient rendering** suitable for real-time interaction

## Technical Notes
- Use **fixed-point iteration** principles from the research paper for convergence
- Implement **conservative updates** to maintain geometric constraints
- Consider **aspect ratio** of the bar when calculating optimal circle sizes
- Ensure **numerical stability** in the tangency calculations

This implementation will create true circle packing that fills space efficiently while maintaining the mathematical rigor described in the Collins & Stephenson paper.